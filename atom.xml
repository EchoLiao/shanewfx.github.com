<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[思考的轨迹]]></title>
  <link href="http://shanewfx.github.com/atom.xml" rel="self"/>
  <link href="http://shanewfx.github.com/"/>
  <updated>2012-03-31T12:19:27+08:00</updated>
  <id>http://shanewfx.github.com/</id>
  <author>
    <name><![CDATA[Shane]]></name>
    <email><![CDATA[shanewfx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VS2005 64-bit Programming Note]]></title>
    <link href="http://shanewfx.github.com/blog/2012/03/26/vs2005-64bit-programming/"/>
    <updated>2012-03-26T17:47:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/03/26/vs2005-64bit-programming</id>
    <content type="html"><![CDATA[<p>最近接到的任务是将32位的directshow filter移植到64位平台下，因此，借此机会学习了一点关于64位编程方面的内容。</p>

<p>由于平时的开发环境是Windows + VS2005，所以，下面的内容也主要是讨论VS2005下64位编程的一些主要事项。不过，对于其他平台下的64位编程也有参考价值。</p>

<p>之前已经讲过如何搭建VS2005下64位编程环境，看<a href="http://shanewfx.github.com/blog/2012/03/18/64bit-programming/">这里</a>。</p>

<!--more-->


<h2>关于Windows下64位编程，有如下几篇文章可做参考：</h2>

<ul>
<li><p><a href="http://www.microsoft.com/china/MSDN/library/Windev/64bit/issuesx64.mspx?mfr=true">开始进行64位Windows系统编程之前需要了解的所有信息</a></p></li>
<li><p><a href="http://www.viva64.com/en/l/full/">Lessons on development of 64-bit C/C++ applications</a>, <a href="http://www.cnblogs.com/walfud/articles/2291839.html">中文学习笔记</a></p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/bb427430.aspx">Programming Guide for 64-bit Windows</a></p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/aa384198.aspx">Getting Ready for 64-bit Windows</a></p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/aa384214.aspx">Migration Tips</a></p></li>
<li><p><a href="http://www.usidcbbs.com/read.php?tid=5247">用VC进行64位编程</a></p></li>
<li><p><a href="http://wenku.baidu.com/view/61804438376baf1ffc4fad48.html">Introduction_to_x64_Assembly</a></p></li>
</ul>


<h2>VS2005下64位编程注意事项</h2>

<h3>1. 数据类型模型改变</h3>

<p>Windows 32位平台下使用的是ILP32模型，而Windows 64位平台下使用LLP64模型。</p>

<p>在LLP64模型中，只有指针为64位，其余的类型则保证和32位平台一致:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char   -> 1byte
</span><span class='line'>short  -> 2bytes
</span><span class='line'>int    -> 4bytes
</span><span class='line'>long   -> 4bytes</span></code></pre></td></tr></table></div></figure>


<p>Windows平台为开发者提供了很多的数据类型别名，合理使用这些数据类型为我们编写32位和64位共用代码是有帮助的。</p>

<p>长度固定的类型：
INT32、UINT32、LONG32、ULONG32、DWORD32、INT64、UINT64、LONG64、ULONG64、DWORD64</p>

<p>随平台长度变化的类型（32位平台->32位，64位平台->64位）：
INT_PTR、UINT_PTR、LONG_PTR、ULONG_PTR、DWORD_PTR、SIZE_T、SSIZE_T、HALF_PTR、UHALF_PTR</p>

<p>指针：
POINTER_32、POINTER_64</p>

<p>由于数据类型模型的改变，因此，如果原代码中有涉及指针与整数类型之间相互转换（如在设置回调函数指针时，通常会将原模块的this指针作为long型保存起来），则这部分代码必须要改变（将long改为ULONG_PTR），即任何在代码中有假设指针与整数类型位数相同的代码在64位下都会有问题。</p>

<p>涉及指针运算的地方，要检测偏移量是否可能会溢出的问题。（偏移量是通过无符号数和有符号数运算得来的，特别容易出现问题）</p>

<p>另外，64位系统的API函数参数的数据类型可能发生了改变，如LPARAM，WPARAM，LRESULT在32位平台下是32位整型，而在64位平台下则为64位整型，这也是在移植过程中需要注意的地方，防止出现数据截断。</p>

<p>如果API或者自己代码中使用了size_t和ptrdiff_t，要注意它们的长度在32位平台为32位，在64位平台则是64位，这是特别容易出现数据截断的地方。</p>

<p>函数重载（多态）也要留意是否是仅依靠参数的数据类型来区分的。</p>

<p>代码中魔术数也是要check的地方，如果是魔术数是用来假设数据类型的size时，最好要使用sizeof来确定数据类型的size; 另外，魔术数不管是在32位平台还是在64位平台都是被当作一个32位的整型数来处理，特别要留意将-1作为错误码的地方，在32位平台下为0xFFFFFFFF, 而在64为平台下则应该为0xFFFFFFFFFFFFFFFF。如果代码中使用了0xFFFFFFFF这个整型数，那么在32位平台下为-1, 但在64位下却是一个很大的值(0x00000000FFFFFFFF)。因此，代码中有移位操作和使用MASK的地方，也是容易出现数据溢出的地方。</p>

<p>在代码中，打印整型数和指针的地方也需要注意，打印UINT_PTR整数将%u改为%Iu, 对于指针使用%p。</p>

<h3>2. 汇编代码</h3>

<p>在VS2005下64位编程不再支持内联汇编，汇编代码需要提取到一个单独的.ASM文件中。</p>

<p>编写64位平台汇编代码需要注意以下几个与32位平台汇编的不同的地方：</p>

<ul>
<li>扩展并增加了寄存器</li>
</ul>


<p>[32位] EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP -> [64位] RAX、RBX、RCX、RDX、RSI、RDI、RBP、RSP</p>

<p>可以在64位程序中调用32位的寄存器，如RAX（64位）、EAX（低32）、AX（低16位）、AL（低8位）、AH（8到15位），
相应的有R8、R8D、R8W和R8B，不过不要在程序中使用如AH之类的寄存器</p>

<p>增加了以下寄存器：R8 ~ R15  XMM8 ~ XMM15</p>

<ul>
<li>函数调用约定和参数传递方式</li>
</ul>


<p>x64平台函数calling convention与x86平台函数calling convention是不同的。</p>

<p>在x86平台下，函数调用约定有：<code>__cdecl、__stdcall、__fastcall、__thiscall</code>等，而x64下的调用约定只作如下限制：</p>

<ul>
<li>前4个整数参数（从左至右）通过4个寄存器传递：RCX、RDX、R8、R9，前4个以外的整数参数将传递到堆栈, 指针被视为整数参数;</li>
</ul>


<p>对于浮点参数，前4个参数将传入XMM0到XMM3的寄存器，后续的浮点参数也是通过堆栈传递。</p>

<p>即使参数可以是通过寄存器传递，但在堆栈上仍需为其预留空间，每个函数至少要在堆栈上预留32个字节（为前4个参数预留空间）, 该空间允许将传递函数函数的寄存器轻松地复制到堆栈中。</p>

<p>当然，如果要传递4个以上的参数，则必须为其预额外的堆栈空间。</p>

<ul>
<li>调用者负责椎栈空间的分配与回收，被调用函数不需要自己负责平衡堆栈（仅用于传递参数的这部分堆栈空间）</li>
</ul>


<p>注意，被调用函数中有局部变量和保存其他寄存器时，其空间是由被调用函数来分配，并在结束时由自己去回收这部分堆栈空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>|参数6| &lt;-------------------- rsp + 48  &lt;------------ 栈底 
</span><span class='line'>|参数5| &lt;-------------------- rsp + 40
</span><span class='line'>|参数4| &lt;-------------------- rsp + 32 (R9)
</span><span class='line'>|参数3| &lt;-------------------- rsp + 24 (R8)
</span><span class='line'>|参数2| &lt;-------------------- rsp + 16 (RDX)
</span><span class='line'>|参数1| &lt;-------------------- rsp + 8  (RCX)
</span><span class='line'>|函数返回地址| &lt;------------- rsp
</span><span class='line'>|局部变量...|  &lt;------------- rsp会向低地址移动，上述的取参数的偏移地址也需要改动</span></code></pre></td></tr></table></div></figure>


<p>如int foo(int a, int b, int c, int d, int e, int f) { int i, j; return 0; }</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>|参数f| &lt;-------------------- rbp + 80  &lt;------------ 栈底 
</span><span class='line'>|参数e| &lt;-------------------- rbp + 72
</span><span class='line'>|参数d| &lt;-------------------- rbp + 64 (R9)
</span><span class='line'>|参数c| &lt;-------------------- rbp + 56 (R8)
</span><span class='line'>|参数b| &lt;-------------------- rbp + 48 (RDX)
</span><span class='line'>|参数a| &lt;-------------------- rbp + 40 (RCX)
</span><span class='line'>|函数返回地址| &lt;------------- rbp + 32 ==> 没有分配局部变量空间和保存寄存器前的rsp
</span><span class='line'>|保存RBP|      &lt;------------- rbp + 24
</span><span class='line'>|保存RBX|      &lt;------------- rbp + 16
</span><span class='line'>|保存RSI|      &lt;------------- rbp + 8
</span><span class='line'>|保存RDI|      &lt;------------- rbp - 0  ==> 分配局部变量空前的rsp，并将rsp保存到rbp中         
</span><span class='line'>|局部变量j|    &lt;------------- rbp - 8   &lt;------------ rsp' + 8
</span><span class='line'>|局部变量i|    &lt;------------- rbp - 24  &lt;------------ rsp'     (局部变量先定义的在低地址)</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MOV [RSP+ 8], RCX
</span><span class='line'>MOV [RSP+16], RDX
</span><span class='line'>MOV [RSP+24], R8
</span><span class='line'>MOV [RSP+32], R9
</span><span class='line'>PUSH RBP
</span><span class='line'>PUSH RBX
</span><span class='line'>PUSH RSI
</span><span class='line'>PUSH RDI
</span><span class='line'>MOV RBP, RSP
</span><span class='line'>SUB RSP, 16
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>ADD RSP, 16
</span><span class='line'>POP RDI
</span><span class='line'>POP RSI
</span><span class='line'>POP RBX
</span><span class='line'>POP RBP
</span><span class='line'>RET</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Simple Log Tool]]></title>
    <link href="http://shanewfx.github.com/blog/2012/03/18/a-simple-log-tool/"/>
    <updated>2012-03-18T20:10:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/03/18/a-simple-log-tool</id>
    <content type="html"><![CDATA[<p>对于程序员来说，debug是再正常不过的事。</p>

<p>在遇到问题时，通过分析程序的产生的Log文件来查找和验证问题发生的原因。</p>

<p>下面是一个简单的log tool，可以满足一般的log需求。</p>

<p>代码已经放到Github上了，需要的可到<a href="https://github.com/shanewfx/Log">这里</a>下载。</p>

<!--more-->


<p>该log tool实现了log分级，也支持自己指定log file的存放位置，缺省情况下，log文件为<code>C:\DebugInfo.log</code>。</p>

<p>因为log没有加锁，所以在多线程下产生的log会有错乱的现象，因此，在多线程中，可以在Log()函数的开始处加锁来解决。</p>

<hr />

<h3>log.h</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#ifndef _LOG_H
</span><span class='line'>#define _LOG_H
</span><span class='line'>
</span><span class='line'>#include &lt;string>
</span><span class='line'>
</span><span class='line'>#define TEST
</span><span class='line'>#define LOG_FILE_PATH "C:\\DebugInfo.log"
</span><span class='line'>
</span><span class='line'>#ifdef TEST
</span><span class='line'>  #define LogData Logger::Instance().Log
</span><span class='line'>  #define SetLogFile Logger::SetLogFilePath
</span><span class='line'>#else
</span><span class='line'>  #define LogData
</span><span class='line'>  #define SetLogFile
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>typedef enum tagLogLevel
</span><span class='line'>{
</span><span class='line'>  LOG_TRACE,
</span><span class='line'>  LOG_INFO,
</span><span class='line'>  LOG_WARNING,
</span><span class='line'>  LOG_ERROR,
</span><span class='line'>  LOG_FATAL,
</span><span class='line'>  LOG_NONE = 10,
</span><span class='line'>}LogLevel;
</span><span class='line'>
</span><span class='line'>class Logger
</span><span class='line'>{
</span><span class='line'>public:
</span><span class='line'>  static Logger& Instance();
</span><span class='line'>
</span><span class='line'>  static void SetLogFilePath(const std::string& strFilePath, bool bAppend = false);
</span><span class='line'>  static void SetLogLevel(const LogLevel Level);
</span><span class='line'>  static void Initialise(bool bAppend = false);
</span><span class='line'>  static void Dispose();
</span><span class='line'>
</span><span class='line'>  void Log(const LogLevel Level, const char *Format, ...);
</span><span class='line'>
</span><span class='line'>private:
</span><span class='line'>  Logger();
</span><span class='line'>  Logger(Logger const&);
</span><span class='line'>  Logger& operator=(Logger const&);
</span><span class='line'>  ~Logger();
</span><span class='line'>
</span><span class='line'>  static FILE*        m_hLogFile;
</span><span class='line'>  static std::string  m_strFilePath;
</span><span class='line'>  static LogLevel     m_LogLevel;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>#endif//_LOG_H</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>log.cpp</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "log.h"
</span><span class='line'>#include &lt;stdarg.h>
</span><span class='line'>#include &lt;windows.h>
</span><span class='line'>
</span><span class='line'>FILE* Logger::m_hLogFile = NULL;
</span><span class='line'>LogLevel Logger::m_LogLevel = LOG_TRACE;
</span><span class='line'>std::string Logger::m_strFilePath = LOG_FILE_PATH;
</span><span class='line'>
</span><span class='line'>const char* LogLevelStr[] = {
</span><span class='line'>    "TRACE",
</span><span class='line'>    "INFO",
</span><span class='line'>    "WARNING",
</span><span class='line'>    "ERROR",
</span><span class='line'>    "CRITICAL",
</span><span class='line'>    "FATAL",
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>Logger& Logger::Instance() 
</span><span class='line'>{
</span><span class='line'>  static Logger LoggerInstance;
</span><span class='line'>  return LoggerInstance;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::SetLogFilePath(const std::string& strFilePath, bool bAppend)
</span><span class='line'>{
</span><span class='line'>  m_strFilePath = strFilePath;
</span><span class='line'>  Dispose();
</span><span class='line'>  Initialise(bAppend);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::SetLogLevel(const LogLevel Level)
</span><span class='line'>{
</span><span class='line'>  m_LogLevel = Level;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>Logger::Logger()
</span><span class='line'>{
</span><span class='line'>  Initialise(false);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>Logger::~Logger()
</span><span class='line'>{
</span><span class='line'>  Dispose();
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::Initialise(bool bAppend)
</span><span class='line'>{
</span><span class='line'>  if (m_strFilePath.length() > 0) {
</span><span class='line'>      m_hLogFile = bAppend ? fopen(m_strFilePath.c_str(), "a+") 
</span><span class='line'>                       : fopen(m_strFilePath.c_str(), "w+");  
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::Dispose()
</span><span class='line'>{
</span><span class='line'>  if (NULL != m_hLogFile) {
</span><span class='line'>      fflush(m_hLogFile);
</span><span class='line'>      fclose(m_hLogFile);
</span><span class='line'>      m_hLogFile = NULL;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void Logger::Log(const LogLevel Level, const char *Format, ...)
</span><span class='line'>{
</span><span class='line'>  if (m_LogLevel > Level) return;
</span><span class='line'>
</span><span class='line'>  if (NULL == m_hLogFile) return; 
</span><span class='line'>
</span><span class='line'>  char szBuffer[1024];
</span><span class='line'>
</span><span class='line'>  va_list args;
</span><span class='line'>  va_start(args, Format);
</span><span class='line'>  vsprintf(szBuffer, Format, args);
</span><span class='line'>  va_end(args);
</span><span class='line'>
</span><span class='line'>  SYSTEMTIME st;      
</span><span class='line'>  GetLocalTime(&st);
</span><span class='line'>  if (0 > fprintf(m_hLogFile, "[%02u:%02u:%02u:%03u]\t[%s]\t%s\n", 
</span><span class='line'>      st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, 
</span><span class='line'>      LogLevelStr[Level], szBuffer)) {
</span><span class='line'>      Dispose();
</span><span class='line'>  }
</span><span class='line'>  else {
</span><span class='line'>      fflush(m_hLogFile);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>log的使用示例</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "Log.h"
</span><span class='line'>
</span><span class='line'>LogData(LOG_TRACE, "log information\n");
</span><span class='line'>
</span><span class='line'>int i = 100;
</span><span class='line'>LogData(LOG_TRACE, "i = %d\n", i);
</span><span class='line'>
</span><span class='line'>int j = 10;
</span><span class='line'>LogData(LOG_TRACE, "i = %d, j = %d\n", i, j);
</span><span class='line'>
</span><span class='line'>SetLogFile("c:\\log.txt"); //set log file path</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VS2005下的64位编程与移植]]></title>
    <link href="http://shanewfx.github.com/blog/2012/03/18/64bit-programming/"/>
    <updated>2012-03-18T17:34:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/03/18/64bit-programming</id>
    <content type="html"><![CDATA[<p>最近有个项目需要将32位下的代码移植到64位下，之前没有做过这方面的工作，特别向同事请教了这方面的知识，在此记录下来。</p>

<!--more-->


<h2>VS2005下64位编程环境</h2>

<ol>
<li><p>VS2005安装时要勾选X64 Compilers and Tools，如果安装时忘记了，则可以重新打开VS2005安装程序来添加；</p></li>
<li><p>VS2005X64编程环境设置</p></li>
<li><p>在VS2005的Build菜单下选择Configuration Management；</p></li>
<li><p>在Configuration Management对话框中的Active solution platform下选择New；</p></li>
<li><p>在New Solution Platform中的Type or select the new platform下选择x64，OK。</p></li>
</ol>


<p>对于没有汇编的程序，上述设置就可以了。但如果代码中有汇编代码，则还需要Project下的Custom Build Rules中切换到MASM64 Bulid Rule。</p>

<p>缺省情况下，VS2005没有提供到MASM64 Bulid Rule，需要将原来的masm.rules（在C:\Program Files\Microsoft Visual Studio 8\VC\VCProjectDefaults文件夹下）文件拷贝一份，重新命名为masm64.rules，并在VS2005中修改rule中的ml.exe为ml64.exe即可。</p>

<p>上面设置好之后，就可以在Win32和X64平台间自由切换，但要注意的是，切换的时候也需要将Custom Build Rules切换到相应的平台下。</p>

<h2>VS2005下64位编程的注意事项</h2>

<ul>
<li><p>X64平台下，不支持内联汇编，必须将汇编代码提取到独立的.asm文件中去；</p></li>
<li><p>指针不再是32位，而是64位，汇编代码中涉及32位寄存器间接寻址的，移植时需要修改；</p></li>
<li><p>32位的寄存器被扩展为64位，又增加了一些新的寄存器；</p></li>
<li><p>函数参数的传递与32位下汇编不再相同，而是前4个参数分别通过RCX, RDX, R8, R9来传递，其他的参数通过堆栈来传递；</p></li>
</ul>


<p>上述的应该是最基本的，要在64位平台中进行编程，还需要了解更多的这方面的知识。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compile Boost v1.49.0]]></title>
    <link href="http://shanewfx.github.com/blog/2012/03/17/compile-boost-v1-dot-49-dot-0/"/>
    <updated>2012-03-17T21:15:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/03/17/compile-boost-v1-dot-49-dot-0</id>
    <content type="html"><![CDATA[<p>对C++程序员来说，Boost是一个非常有名的库，里面提供了很多强大的功能。</p>

<p>不过，我之前一直没有使用和研究过Boost，最近看一些开源的代码中有使用Boost，感觉很不错，于是，今天抽一点时间先将Boost的使用环境先搭起来，后面慢慢学习。</p>

<!--more-->


<h2>编译Boost</h2>

<ul>
<li><p>先到<a href="http://www.boost.org/">Boost的官方网站</a>上下载最新的版本Boost v1.49.0, 我选择的是<a href="http://sourceforge.net/projects/boost/files/boost/1.49.0/">boost_1_49_0.7z</a>;</p></li>
<li><p>将下载的boost_1_49_0.7z解压缩到D:\Program Files\boost_1_49_0中;</p></li>
<li><p>为了自动编译Boost，编写了下面的Batch，将Batch代码拷贝到文本文件中，重新命名为为compile_boost_1_49_0.bat;</p></li>
</ul>


<div><script src='https://gist.github.com/2058696.js?file='></script>
<noscript><pre><code>em @echo off

rem 先编译bjam
start bootstrap.bat

rem 等待一分钟待bjam编译完成（如果电脑性能过差，可以设置等待时间更长一些）
SET SLEEP=ping 127.0.0.1 -n
%SLEEP% 60 &gt; nul

rem 利用bjam编译boost库
rem 在此，我们编译vs2005下的x86及x64共2类boost库文件

rem 建立库文件夹
rem vs2005 win32库文件夹
md stage\lib\win32\vs8_0\

rem vs2005 x64库文件夹
md stage\lib\x64\vs8_0\


rem ******************************************************************
rem 先删除lib下所有文件（不删除文件夹）
del stage\lib\*.* /Q

rem 编译vs2005 win32库文件
bjam --toolset=msvc-8.0 architecture=x86 --build-type=complete stage

rem 拷贝至\stage\lib\win32\vs8_0
copy stage\lib\*.* stage\lib\win32\vs8_0\*.* /Y
rem ##################################################################

rem ******************************************************************
rem 先删除lib下所有文件（不删除文件夹）
del stage\lib\*.* /Q

rem 编译vs2008 x64库文件
bjam --toolset=msvc-8.0 architecture=x86 address-model=64 --build-type=complete stage

rem 拷贝至\stage\lib\x64\vs8_0
copy stage\lib\*.* stage\lib\x64\vs8_0\*.* /Y
rem ##################################################################

rem 删除lib下所有文件（不删除文件夹）
del stage\lib\*.* /Q</code></pre></noscript></div>


<p>由于我使用的VS2005，所以使用了<code>--toolset=msvc-8.0</code>。</p>

<p>如果使用的是其他版本的VS，则上述的代码要作一点小修改，具体就是：</p>

<p>VS2008 -> <code>--toolset=msvc-9.0</code>     VS2010 -> <code>--toolset=msvc-10.0</code></p>

<p>当然，lib的存放的路径也可以改动一下。</p>

<ul>
<li><p>将上面的compile_boost_1_49_0.bat文件拷贝到D:\Program Files\boost_1_49_0目录中;</p></li>
<li><p>双击运行compile_boost_1_49_0.bat，这样就开始了漫长的自动编译过程，整个过程大概要2小时（编译了32位和64位的全部lib）;</p></li>
<li><p>编译结束后，生成的Libs都在D:\Program Files\boost_1_49_0\stage\lib\win32\vs8_0和D:\Program Files\boost_1_49_0\stage\lib\x64\vs8_0两个文件夹下；</p></li>
</ul>


<p>到这里Boost编译的过程就结束了。</p>

<h2>设置VS2005</h2>

<ul>
<li><p>在Tools->Options->Projects and Solutions->VC++ Directories中：</p>

<pre><code>- Win32平台加入Include files和Library files的路径
    - Include files: D:\Program Files\boost_1_49_0
    - Library files: D:\Program Files\boost_1_49_0\stage\lib\win32\vs8_0

- X64平台加入Include files和Library files的路径
    - Include files: D:\Program Files\boost_1_49_0
    - Library files: D:\Program Files\boost_1_49_0\stage\lib\x64\vs8_0
</code></pre></li>
<li><p>通过上述的设置，在VS2005中就可以正常使用Boost了。</p></li>
</ul>


<p><strong>相信此时你一定很激动，赶紧写个测试程序，来体验一下Boost的强大功能吧!</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARIB Closed Caption]]></title>
    <link href="http://shanewfx.github.com/blog/2012/03/07/isdb-t-slash-sbtvd-t-closed-caption/"/>
    <updated>2012-03-07T16:40:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/03/07/isdb-t-slash-sbtvd-t-closed-caption</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Closed_captioning">Closed Caption</a>（可简称为CC）可以简单来看作为一种字幕，最初设计的目的是为了帮助有听力障碍的人理解电视节目的内容，即将节目中的Audio（背景音乐显示音乐符号）通过文字在屏幕上显示出来。</p>

<p>目前，Closed Caption的标准主要有ATSC定义的608和708，日本ARIB STD-B24等，而巴西的数字电视标准SBTVD-T是在日本的ISDB-T标准基础上稍作修改而来，因此，巴西数字电视的Closed Caption标准也是采用了ARIB STD-B24。</p>

<p>ARIB STD-B24定义的Closed Caption下面被简称为ARIB CC。</p>

<!--more-->


<p>ATSC CC与ARIB CC的数据传输区别在于:</p>

<ul>
<li>ATSC的CC数据是通过MPEG-2 Video中的User Data部分进行传输；</li>
<li>ARIB的CC数据是在TS流中以独立的ES进行传输。</li>
</ul>


<p>下面将介绍ARIB STD-B24标准中Closed Caption的一些细节内容。</p>

<h3>ARIB CC传输层</h3>

<p>ARIB CC数据首先被打包为Synchronized PES（Independent PES），然后，Synchronized PES会继续被打包为PES packet中，该PES packet的stream id为0xBD，同时PES packet header中需要含有PTS，最后，该PES会被打包为TS packet，在TS中进行传输。</p>

<p>如果TS流中含有Closed Caption，则在TS流的PMT和EIT中会有相应的descriptors进行描述。载有Closed Caption的ES流在PMT中的stream type值为0x06，因此，可通过在PMT表中查找stream type为0x06的Closed Caption ES对应的PID，从而，可从TS流中过滤出Closed Caption ES对应的TS packet。</p>

<h3>ARIB CC Data的语法结构:</h3>

<p>Synchronized PES -> Data Group -> Caption Management
Synchronized PES -> Data Group -> Caption Statement -> data_unit</p>

<p>Caption Management包含了Closed Caption的全局信息，并以一定的时间间隔来发送。另外，Caption Management中一般不会含有Closed Caption字符编码数据（没有包含data_unit）。</p>

<p>Caption Statement是Closed Caption数据传输的主要载体。CC数据主要由Control Code（控制字）和Character Code（字符码）组成，其中，控制字规定了CC的字符集、显示位置及文本格式等信息，而通过字符码可以从指定的字符集中取得CC字符。Closed Caption的控制字和字符码都在data_unit中。</p>

<h3>ARIB CC的控制字</h3>

<p>ARIB CC的整个字符集被分为4个区域：C0、GL、C1、GR，其中C0和C1对应是Control Code，而GL和GR对应的则是CC当前使用的字符集。可以使用不同的控制字（LS0、LS1、LS1R、LS2、LS3、LS2R、LS3R、SS2、SS3）将不同的字符集(G0、G1、G2、G3)调用到GL和GR中，而G0、G1、G2、G3具体对应哪一个字符集则可以用ESC控制字来指明。</p>

<p>除了C0和C1中的控制字之外，通过CSI控制字又扩展出一些其他的控制字: SWF、SDF、SDP、SSM、SHS、SVS、RCS、ACPS、ORN、SCR、TCC、SCS、ACS、PPA、XCS、MDF、CFS、SRC、GAA、GSM、PLD、PLU、CCC。</p>

<p>在这些控制字中，有一些控制字没有被使用，有些则不是必须实现的: BEL、CAN、RS、CDC、WMM、MACRO、TIME、TCC、SCS、ACS、PPA、XCS、MDF、CFS、SRC、GAA、GSM、PLD、PLU、CCC。</p>

<p>CC的控制字基本可以分为以下几类：</p>

<ul>
<li>Display Format：SWF、SDF、SDP、SSM、SHS、SVS</li>
<li>Color：BKF、RDF、GRF、YLF、BLF、MGF、CNF、WHF、COL、RCS、POL</li>
<li>Cursor Position：APB、APF、APD、APU、APR、APS、PAPF、ACPS</li>
<li>Character Set：LS0、LS1、SS2、SS3、ESC</li>
<li>Character Size：SSZ、MSZ、NSZ、SZX</li>
<li>Display Effect：ORN、SCR、FLC、HLC、SPL、STL （可选）</li>
<li>Clear Screen：CS</li>
</ul>


<h3>CC显示相关的控制字</h3>

<ul>
<li>SWF指定了Caption Plane的大小和Caption Text的Print Direction;</li>
<li>SDF指定了Caption Display Window的size, Caption Display Window始终在Caption Plane内;</li>
<li>SDP指定了Caption display window左上角的坐标，该坐标值是相对于Caption Plane的左上角坐标（0, 0）;</li>
<li>根据SDF和SDP就可以确定Caption display window在Caption Plane内的位置及Size;</li>
<li>SSM指定了Normal Font的Size;</li>
<li>SHS指定了同一行字符之间的间隔;</li>
<li>SVS指定了行与行之间的间隔;</li>
</ul>


<p>根据SSM、SHS、SVS可以知道每个字符所占Size, 不同字体大小的字符Size也不尽相同;</p>

<p>上述的这些控制字一般在每个Caption Statement的开始都会出现，通过这些控制字，则可以推断出在Caption display window内所能够容纳的字符个数，即总的行数和每行可以显示字符的最大个数。</p>

<h3>CC字符的颜色和背景色控制字</h3>

<p>BKF、RDF、GRF、YLF、BLF、MGF、CNF、WHF这8个控制字指定字符的前景色(foreground color)，而字符的背景色(background color)和half foreground color及half background color均是通过COL控制字来指定。</p>

<p>Closed Caption总共使用了128种颜色，这些控制字除了指定了color值，同时也指定了改color值在Color map table中Index的低4位（CMLA），而Color map table Index的高4位（Pallete Number）也由COL来指定（取值范围：0~7）。</p>

<h3>CC字符显示位置的控制字</h3>

<p>APB、APF、APD、APU、APR、APS、PAPF、ACPS控制了下一个字符在caption display window中插入的位置。</p>

<p>APB、APF、APD、APU分别控制了当前Cursor向后、向前、向下、向上移动一个字符的位置；</p>

<p>APR控制了字符的换行；</p>

<p>APS控制了新的Caption起始的Cursor位置；</p>

<p>PAPF跟有一个参数P1，控制了当前Cursor向前移动其参数P1指定的字符个数；</p>

<p>ACPS指定了Cursor在Caption Plane中的绝对位置（字符的左下角坐标）。</p>

<h3>CC字符集相关的控制字</h3>

<p>LS0、LS1、SS2、SS3控制调用指明了的字符集（G0、G1、G2、G3）到GL或者GR中。</p>

<ul>
<li>LS0调用G0对应的字符集到GL中；</li>
<li>LS1调用G1对应的字符集到GL中；</li>
<li>SS2临时调用G2中的字符到GL中；</li>
<li>SS3临时调用G3中的字符到GL中。</li>
</ul>


<p>除了C0中明确定义的这几个字符集控制字外，其他的字符集控制字则通过ESC控制字扩展来定义（LS2、LS3、LS1R、LS2R、LS3R）。</p>

<p>ESC控制字除了上述用来扩展字符集调用命令控制字外，还可以用来指明G0、G1、G2、G3分别对应何种字符集。G0、G1、G2、G3、GL、GR的初始值在Spec中也指定了。</p>

<h3>CC字符Font相关的控制字</h3>

<p>SSZ、MSZ、NSZ、SZX用于控制了相对于SSM指定的Normal Font Size的字符大小。</p>

<p>SSZ、MSZ、NSZ分别指定了字符的大小为samll、middle、normal。</p>

<hr />

<p>这两周一直在做日本DTVCC，不过这次不是从零开始，而是在之前巴西的DTVCC Decoder上增加对日本Closed Caption的支持，主要的工作集中在对日本字符集的支持上，最复杂的部分就是构建一个Kanji字符集（JIS X 213 : 2004）的Unicode映射表。</p>

<p>JIS X 213 : 2004表见<a href="http://seiai.ed.jp/sys/text/cs/mcodes/jis0213table.html">这里</a>。</p>

<h3>ISDB-T/SBTVD-T Closed Caption相关的Spec</h3>

<ul>
<li><p>ARIB STD-B24 VOL1 PART2 (Chapter 7: Character Coding): CC字符集；</p></li>
<li><p>ARIB STD-B24 VOL1 PART3 (Coding of Caption and Superimpose): CC Data的syntax；</p></li>
<li><p>ARIB STD-B24 VOL3 (Chapter 5: Independent PES): Independent PES的syntax；</p></li>
<li><p>ARIB TR-B14 VOL3 Section2 (Chapter 4: Operation of caption and superimpose encoding): Closed Caption的显示；</p></li>
<li><p>ABNT NBR 15606-1 (11.4 Character coding): 关于巴西Closed Caption在字符编码上的一些限制</p></li>
<li><p>ABNT NBR 15608-3 (Chapter 5 / 14 / 22): 关于巴西Closed Caption在PMT及EIT上descriptor的定义和解释</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Markdown来写博客文章]]></title>
    <link href="http://shanewfx.github.com/blog/2012/02/16/markdown-syntax/"/>
    <updated>2012-02-16T15:27:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/02/16/markdown-syntax</id>
    <content type="html"><![CDATA[<p><strong>Octopress一大亮点是支持博客使用<a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a>作为源文件语言。</strong></p>

<p><strong>Markdown</strong>语言由于其<strong>简单</strong>，<strong>易读</strong>和<strong>清晰</strong>的脉络结构的特点，被许多网站采用，比如<strong>Github</strong>，<strong>Google Code</strong>，<strong>StackOverflow</strong>。</p>

<p><strong>Markdown</strong>是一个很好的文档语言，可以写出很漂亮的文档出来。</p>

<p>实际使用下来发现: <strong>用Markdown来写博客文章是一件很爽的事!</strong></p>

<!-- more -->


<p><a href="http://www.ituring.com.cn/article/details/775">Markdown基本语法</a>很简洁，也很好记。</p>

<p>下面是<a href="http://daringfireball.net/projects/markdown/dingus">Dingus</a>支持的<strong>Markdown Syntax</strong>。</p>

<div><script src='https://gist.github.com/2009731.js?file='></script>
<noscript><pre><code>Markdown Syntax:


1.Phrase Emphasis 斜体与加粗

*italic*   **bold**
_italic_   __bold__

2.Links 超链接

方法1 Inline:
An [example](http://url.com/ &quot;Title&quot;)

方法2 Reference-style labels (titles are optional):
An [example][id]

Then, anywhere else in the doc, define the link:
[id]: http://example.com/  &quot;Title&quot;

3.Images 插入图片

方法1 Inline (titles are optional):
![alt text](/path/img.jpg &quot;Title&quot;)

方法2 Reference-style:
![alt text][id]

[id]: /url/to/img.jpg &quot;Title&quot;

4.Headers 标题

方法1 Setext-style:
Header 1
========

Header 2
--------

方法2 atx-style (closing #'s are optional):
# Header 1 #

## Header 2 ##

###### Header 6

5.Lists 列表

有序列表 Ordered, without paragraphs:
1.  Foo
2.  Bar

无序列表 Unordered, with paragraphs:
*   A list item.

    With multiple paragraphs.

*   Bar

You can nest them:
*   Abacus
    * answer
*   Bubbles
    1.  bunk
    2.  bupkis
        * BELITTLER
    3. burper
*   Cunning

6.Blockquotes 块引用

&gt; Email-style angle brackets
&gt; are used for blockquotes.

&gt; &gt; And, they can be nested.

&gt; #### Headers in blockquotes
&gt; 
&gt; * You can quote a list.
&gt; * Etc.

7.Code Spans 代码段

`&lt;code&gt;` spans are delimited by backticks.

You can include literal backticks
like `` `this` ``.

Preformatted Code Blocks

Indent every line of a code block by at least 4 spaces or 1 tab.
This is a normal paragraph.

    This is a preformatted
    code block.

8.Horizontal Rules 水平分割线

Three or more dashes or asterisks:
---

* * *

- - - - 

9.Manual Line Breaks 换行

End a line with two or more spaces:
Roses are red,   
Violets are blue.</code></pre></noscript></div>


<p>看一看实际的示例：<a href="http://dillinger.io/">dillinger</a></p>

<p>要看本博客文章如何使用Markdown的，请看看<a href="https://github.com/shanewfx/shanewfx.github.com">博客的源代码</a>吧。</p>

<p>另外需要了解的是，我们除了可以使用Markdown来写文章，而且可以使用Octopress提供的一些<a href="http://octopress.org/docs/blogging/plugins/">Plugins</a>来实现一些特殊的效果，具体请查看<a href="http://octopress.org/docs/blogging/plugins/">Octopress的官方文档</a>吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何维护Github上博客]]></title>
    <link href="http://shanewfx.github.com/blog/2012/02/16/clone-blog-from-github/"/>
    <updated>2012-02-16T14:59:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/02/16/clone-blog-from-github</id>
    <content type="html"><![CDATA[<p>有了自己的独立博客，日常维护得全靠自己了。</p>

<p>有时，我们需要在不同电脑上对自己博客进行维护或者发表博文。</p>

<p>如果要在一台陌生的电脑(如没有安装Git或者Ruby运行环境等)上进行博客维护，这种情况下, 我们除了需要根据<a href="http://shanewfx.github.com/blog/2012/02/16/bulid-blog-by-octopress/">上一篇文章</a>介绍的那样来安装必要的Git和Ruby运行环境，还需要从Github上克隆一份自己博客，以便进行维护。</p>

<!--more-->


<p>下面以自己的博客为例，看看如何怎么做。</p>

<h4>从Github上Clone博客</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd f:
</span><span class='line'>cd blog
</span><span class='line'>git clone git@github.com:shanewfx/shanewfx.github.com.git</span></code></pre></td></tr></table></div></figure>


<h4>要从克隆下来的博客代码中checkout出&#8221;source分支&#8221;</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd shanewfx.github.com
</span><span class='line'>git checkout source</span></code></pre></td></tr></table></div></figure>


<p>这一步是必须的，否则会出现问题，看<a href="http://fancyoung.com/blog/octopress-study/">这里</a>。</p>

<h4>要重新设置本地博客与Github Page的关联</h4>

<pre><code>rake setup_github_pages
</code></pre>

<p>根据提示输入: git@github.com:shanewfx/shanewfx.github.com.git</p>

<p><strong>到这里，如果rake无法使用，说明octopress依赖的工具还没有被安装好，需要从github上clone一份octopress，并参考<a href="http://shanewfx.github.com/blog/2012/02/16/bulid-blog-by-octopress/">上篇</a>文章中安装octopress部分安装所需的工具。</strong></p>

<p><em>上述的设置完成后，除了删除了本地的博客文件夹，否则以后在本地就可以不用再进行设置，对博客的维护直接进行下面的操作即可。不过，在对博客维护前，最好要从Github上获得最新的博客内容，使用下面这个命令即可:</em>
<code>git pull origin source</code></p>

<h4>对博客进行维护，如修改配置、写博文等</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post["test clone from github"]
</span><span class='line'>rake generate
</span><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<h4>更新博客至Github</h4>

<div><script src='https://gist.github.com/1863884.js?file='></script>
<noscript><pre><code>rake deploy
git add .
git commit -am 'test clone'
git push origin source</code></pre></noscript></div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭Blog 学Git]]></title>
    <link href="http://shanewfx.github.com/blog/2012/02/16/bulid-blog-by-octopress/"/>
    <updated>2012-02-16T14:45:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/02/16/bulid-blog-by-octopress</id>
    <content type="html"><![CDATA[<p>想要有一个自己的独立博客是很久之前的事。</p>

<p>以前也在其他网站上写过自己的博客，但总觉得用的不顺手，感觉少了归属感，最主要是提供的界面感觉都不怎么好。</p>

<p>最近想学学<strong>Git</strong>，知道了<strong>Github</strong>，开始以为就是个代码仓库，后来才发现还提供了page服务，可以用来在上面搭建自己的<strong>独立博客</strong>。</p>

<p>在Github上搭建博客可以利用<a href="https://github.com/mojombo/jekyll/wiki">Jekyll</a>或者<a href="http://octopress.org/">Octopress</a>，Octopress是在Jekyll上建立起来的，即使没有网站设计经验的人也能够快速搭建起自己的博客。</p>

<p>Jekyll和Octopress都是利用<strong>Ruby</strong>实现的，因此在搭建自己博客的过程中难免要接触到一些Ruby的东西，嗯，这说不定也是一个让自己开始了解Ruby的契机。</p>

<p>整个博客的内容和设置都是通过Git进行版本管理的，其中当然需要了解一些基本的Git操作，其实也没有几个常用的命令。</p>

<!--more-->


<p>由于我平时的工作环境都是在Windows上，所以这次搭建博客也在Windows上完成的(我使用的OS是Windows XP)。</p>

<p>下面是我用Octopress搭建博客的过程:</p>

<h2>安装和设置Git</h2>

<p>下载<a href="http://code.google.com/p/msysgit/">Git for Windows</a>，安装完成后就可以在本地使用Git了，但要将内容放到Github上，必须先在Github上注册个账户，然后在本机使用Git创建SSH Key。</p>

<p>在Git Bash上输入命令:</p>

<pre><code>ssh-keygen -C "username@email.com" -t rsa
</code></pre>

<p>Note: username@email.com需要更换成你自己的在Github上注册的Email地址</p>

<p>这样会在用户目录(C:\Documents and Settings\UserName)下产生一个.ssh文件夹，里面为对应的SSH Keys，其中id_rsa.pub是Github需要的SSH公钥文件。</p>

<p>在Github的Account Settings里选择SSH Keys，在其中将id_rsa.pub文件里内容拷贝至
其中的Key里。</p>

<p>这样以后就可以直接使用Git和GitHub了。</p>

<h2>安装Ruby环境</h2>

<p>下载<a href="http://rubyforge.org/frs/?group_id=167">RubyInstaller</a>和<a href="https://github.com/oneclick/rubyinstaller/downloads/">DevKit</a>。</p>

<p>Octopress需要的Ruby版本为1.9.2，所以选rubyinstaller-1.9.2-p290.exe，DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe。</p>

<p>先安装RubyInstaller，然后解压缩DevKit(路径中不能有中文)。</p>

<p>在&#8221;Start Command Prompt with Ruby&#8221;命令行中进入DevKit解压缩的目录，然后运行以下命令:</p>

<pre><code>ruby dk.rb init
ruby dk.rb install
gem install rdiscount --platform=ruby
</code></pre>

<p>如果安装成功，就可以使用一些Ruby的工具了，也为后面搭建博客提供了基础环境。</p>

<h2>安装Octopress</h2>

<p>先通过Git从Github上克隆一份Octopress</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
</code></pre>

<p>然后安装一些依赖的工具</p>

<pre><code>cd octopress
ruby --version # Should report Ruby 1.9.2
gem install bundler
bundle install
</code></pre>

<p>安装Octopress默认的Theme</p>

<pre><code>rake install
</code></pre>

<h2>配置Octopress</h2>

<p>通过修改_config.yml来配置博客，具体可以在<a href="https://github.com/shanewfx/shanewfx.github.com">我的Github</a>上查看具体的配置内容。</p>

<h2>开始写博文</h2>

<p>通过<code>rake new_post["title"]</code>来在<strong>source/_post</strong>下创建一个新的Post，文件名如下面的格式:<strong>2012-02-16-title.markdown</strong>。</p>

<p>然后可以用VIM打开该文件，并在其中输入/编辑文章内容。</p>

<p>写文章时，可以使用<a href="http://daringfireball.net/projects/markdown/">Markdown</a>和<a href="http://octopress.org/docs/blogging/plugins/">Octopress Plugins</a>来对内容进行格式排版。</p>

<h2>预览效果</h2>

<p>在修改设置或者写完文章后，想看看具体效果，可以通过如下命令来完成:</p>

<pre><code>rake generate
rake preview
</code></pre>

<p>然后在浏览器中打开http://localhost:4000/来看一看效果。</p>

<h2>将博客部署到Github上</h2>

<p>在预览的效果符合自己的预期后，就可以通过如下命令将内容部署到Github上了。</p>

<p>第一次部署前需要先要在Github上创建一个<strong>username.github.com</strong>的repository，
然后通过<code>rake setup_github_pages</code>将自己的Blog与上述的repository关联起来。
在其过程中根据提示输入<strong>username.github.com</strong>。</p>

<p>然后就可以通过下面的命令来部署自己的博客内容至Github了:</p>

<pre><code>rake deploy
git status
git add .
git commit -a -m 'comment'
git push origin source
</code></pre>

<h2>开始浏览自己的博客</h2>

<p>在浏览器的地址栏中输入<strong>username.github.com</strong>，打开的网站就是自己的博客了，此刻一个独立博客就如此问世了!</p>

<p>以后就可以享受这种以Geek方式来写博客的生活了!</p>
]]></content>
  </entry>
  
</feed>
