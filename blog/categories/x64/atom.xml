<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: X64 | 思考的轨迹]]></title>
  <link href="http://shanewfx.github.com/blog/categories/x64/atom.xml" rel="self"/>
  <link href="http://shanewfx.github.com/"/>
  <updated>2012-03-31T12:19:27+08:00</updated>
  <id>http://shanewfx.github.com/</id>
  <author>
    <name><![CDATA[Shane]]></name>
    <email><![CDATA[shanewfx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VS2005 64-bit Programming Note]]></title>
    <link href="http://shanewfx.github.com/blog/2012/03/26/vs2005-64bit-programming/"/>
    <updated>2012-03-26T17:47:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/03/26/vs2005-64bit-programming</id>
    <content type="html"><![CDATA[<p>最近接到的任务是将32位的directshow filter移植到64位平台下，因此，借此机会学习了一点关于64位编程方面的内容。</p>

<p>由于平时的开发环境是Windows + VS2005，所以，下面的内容也主要是讨论VS2005下64位编程的一些主要事项。不过，对于其他平台下的64位编程也有参考价值。</p>

<p>之前已经讲过如何搭建VS2005下64位编程环境，看<a href="http://shanewfx.github.com/blog/2012/03/18/64bit-programming/">这里</a>。</p>

<!--more-->


<h2>关于Windows下64位编程，有如下几篇文章可做参考：</h2>

<ul>
<li><p><a href="http://www.microsoft.com/china/MSDN/library/Windev/64bit/issuesx64.mspx?mfr=true">开始进行64位Windows系统编程之前需要了解的所有信息</a></p></li>
<li><p><a href="http://www.viva64.com/en/l/full/">Lessons on development of 64-bit C/C++ applications</a>, <a href="http://www.cnblogs.com/walfud/articles/2291839.html">中文学习笔记</a></p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/bb427430.aspx">Programming Guide for 64-bit Windows</a></p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/aa384198.aspx">Getting Ready for 64-bit Windows</a></p></li>
<li><p><a href="http://msdn.microsoft.com/en-us/library/aa384214.aspx">Migration Tips</a></p></li>
<li><p><a href="http://www.usidcbbs.com/read.php?tid=5247">用VC进行64位编程</a></p></li>
<li><p><a href="http://wenku.baidu.com/view/61804438376baf1ffc4fad48.html">Introduction_to_x64_Assembly</a></p></li>
</ul>


<h2>VS2005下64位编程注意事项</h2>

<h3>1. 数据类型模型改变</h3>

<p>Windows 32位平台下使用的是ILP32模型，而Windows 64位平台下使用LLP64模型。</p>

<p>在LLP64模型中，只有指针为64位，其余的类型则保证和32位平台一致:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char   -> 1byte
</span><span class='line'>short  -> 2bytes
</span><span class='line'>int    -> 4bytes
</span><span class='line'>long   -> 4bytes</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Windows平台为开发者提供了很多的数据类型别名，合理使用这些数据类型为我们编写32位和64位共用代码是有帮助的。</p>

<p>长度固定的类型：
INT32、UINT32、LONG32、ULONG32、DWORD32、INT64、UINT64、LONG64、ULONG64、DWORD64</p>

<p>随平台长度变化的类型（32位平台->32位，64位平台->64位）：
INT_PTR、UINT_PTR、LONG_PTR、ULONG_PTR、DWORD_PTR、SIZE_T、SSIZE_T、HALF_PTR、UHALF_PTR</p>

<p>指针：
POINTER_32、POINTER_64</p>

<p>由于数据类型模型的改变，因此，如果原代码中有涉及指针与整数类型之间相互转换（如在设置回调函数指针时，通常会将原模块的this指针作为long型保存起来），则这部分代码必须要改变（将long改为ULONG_PTR），即任何在代码中有假设指针与整数类型位数相同的代码在64位下都会有问题。</p>

<p>涉及指针运算的地方，要检测偏移量是否可能会溢出的问题。（偏移量是通过无符号数和有符号数运算得来的，特别容易出现问题）</p>

<p>另外，64位系统的API函数参数的数据类型可能发生了改变，如LPARAM，WPARAM，LRESULT在32位平台下是32位整型，而在64位平台下则为64位整型，这也是在移植过程中需要注意的地方，防止出现数据截断。</p>

<p>如果API或者自己代码中使用了size_t和ptrdiff_t，要注意它们的长度在32位平台为32位，在64位平台则是64位，这是特别容易出现数据截断的地方。</p>

<p>函数重载（多态）也要留意是否是仅依靠参数的数据类型来区分的。</p>

<p>代码中魔术数也是要check的地方，如果是魔术数是用来假设数据类型的size时，最好要使用sizeof来确定数据类型的size; 另外，魔术数不管是在32位平台还是在64位平台都是被当作一个32位的整型数来处理，特别要留意将-1作为错误码的地方，在32位平台下为0xFFFFFFFF, 而在64为平台下则应该为0xFFFFFFFFFFFFFFFF。如果代码中使用了0xFFFFFFFF这个整型数，那么在32位平台下为-1, 但在64位下却是一个很大的值(0x00000000FFFFFFFF)。因此，代码中有移位操作和使用MASK的地方，也是容易出现数据溢出的地方。</p>

<p>在代码中，打印整型数和指针的地方也需要注意，打印UINT_PTR整数将%u改为%Iu, 对于指针使用%p。</p>

<h3>2. 汇编代码</h3>

<p>在VS2005下64位编程不再支持内联汇编，汇编代码需要提取到一个单独的.ASM文件中。</p>

<p>编写64位平台汇编代码需要注意以下几个与32位平台汇编的不同的地方：</p>

<ul>
<li>扩展并增加了寄存器</li>
</ul>


<p>[32位] EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP -> [64位] RAX、RBX、RCX、RDX、RSI、RDI、RBP、RSP</p>

<p>可以在64位程序中调用32位的寄存器，如RAX（64位）、EAX（低32）、AX（低16位）、AL（低8位）、AH（8到15位），
相应的有R8、R8D、R8W和R8B，不过不要在程序中使用如AH之类的寄存器</p>

<p>增加了以下寄存器：R8 ~ R15  XMM8 ~ XMM15</p>

<ul>
<li>函数调用约定和参数传递方式</li>
</ul>


<p>x64平台函数calling convention与x86平台函数calling convention是不同的。</p>

<p>在x86平台下，函数调用约定有：<code>__cdecl、__stdcall、__fastcall、__thiscall</code>等，而x64下的调用约定只作如下限制：</p>

<ul>
<li>前4个整数参数（从左至右）通过4个寄存器传递：RCX、RDX、R8、R9，前4个以外的整数参数将传递到堆栈, 指针被视为整数参数;</li>
</ul>


<p>对于浮点参数，前4个参数将传入XMM0到XMM3的寄存器，后续的浮点参数也是通过堆栈传递。</p>

<p>即使参数可以是通过寄存器传递，但在堆栈上仍需为其预留空间，每个函数至少要在堆栈上预留32个字节（为前4个参数预留空间）, 该空间允许将传递函数函数的寄存器轻松地复制到堆栈中。</p>

<p>当然，如果要传递4个以上的参数，则必须为其预额外的堆栈空间。</p>

<ul>
<li>调用者负责椎栈空间的分配与回收，被调用函数不需要自己负责平衡堆栈（仅用于传递参数的这部分堆栈空间）</li>
</ul>


<p>注意，被调用函数中有局部变量和保存其他寄存器时，其空间是由被调用函数来分配，并在结束时由自己去回收这部分堆栈空间</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>|参数6| &lt;-------------------- rsp + 48  &lt;------------ 栈底
</span><span class='line'>|参数5| &lt;-------------------- rsp + 40
</span><span class='line'>|参数4| &lt;-------------------- rsp + 32 (R9)
</span><span class='line'>|参数3| &lt;-------------------- rsp + 24 (R8)
</span><span class='line'>|参数2| &lt;-------------------- rsp + 16 (RDX)
</span><span class='line'>|参数1| &lt;-------------------- rsp + 8  (RCX)
</span><span class='line'>|函数返回地址| &lt;------------- rsp
</span><span class='line'>|局部变量...|  &lt;------------- rsp会向低地址移动，上述的取参数的偏移地址也需要改动</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>如int foo(int a, int b, int c, int d, int e, int f) { int i, j; return 0; }</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>|参数f| &lt;-------------------- rbp + 80  &lt;------------ 栈底
</span><span class='line'>|参数e| &lt;-------------------- rbp + 72
</span><span class='line'>|参数d| &lt;-------------------- rbp + 64 (R9)
</span><span class='line'>|参数c| &lt;-------------------- rbp + 56 (R8)
</span><span class='line'>|参数b| &lt;-------------------- rbp + 48 (RDX)
</span><span class='line'>|参数a| &lt;-------------------- rbp + 40 (RCX)
</span><span class='line'>|函数返回地址| &lt;------------- rbp + 32 ==> 没有分配局部变量空间和保存寄存器前的rsp
</span><span class='line'>|保存RBP|      &lt;------------- rbp + 24
</span><span class='line'>|保存RBX|      &lt;------------- rbp + 16
</span><span class='line'>|保存RSI|      &lt;------------- rbp + 8
</span><span class='line'>|保存RDI|      &lt;------------- rbp - 0  ==> 分配局部变量空前的rsp，并将rsp保存到rbp中       &lt;br/>
</span><span class='line'>|局部变量j|    &lt;------------- rbp - 8   &lt;------------ rsp' + 8
</span><span class='line'>|局部变量i|    &lt;------------- rbp - 24  &lt;------------ rsp'     (局部变量先定义的在低地址)</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MOV [RSP+ 8], RCX
</span><span class='line'>MOV [RSP+16], RDX
</span><span class='line'>MOV [RSP+24], R8
</span><span class='line'>MOV [RSP+32], R9
</span><span class='line'>PUSH RBP
</span><span class='line'>PUSH RBX
</span><span class='line'>PUSH RSI
</span><span class='line'>PUSH RDI
</span><span class='line'>MOV RBP, RSP
</span><span class='line'>SUB RSP, 16&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>ADD RSP, 16
</span><span class='line'>POP RDI
</span><span class='line'>POP RSI
</span><span class='line'>POP RBX
</span><span class='line'>POP RBP
</span><span class='line'>RET</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VS2005下的64位编程与移植]]></title>
    <link href="http://shanewfx.github.com/blog/2012/03/18/64bit-programming/"/>
    <updated>2012-03-18T17:34:00+08:00</updated>
    <id>http://shanewfx.github.com/blog/2012/03/18/64bit-programming</id>
    <content type="html"><![CDATA[<p>最近有个项目需要将32位下的代码移植到64位下，之前没有做过这方面的工作，特别向同事请教了这方面的知识，在此记录下来。</p>

<!--more-->


<h2>VS2005下64位编程环境</h2>

<ol>
<li><p>VS2005安装时要勾选X64 Compilers and Tools，如果安装时忘记了，则可以重新打开VS2005安装程序来添加；</p></li>
<li><p>VS2005X64编程环境设置</p></li>
<li><p>在VS2005的Build菜单下选择Configuration Management；</p></li>
<li><p>在Configuration Management对话框中的Active solution platform下选择New；</p></li>
<li><p>在New Solution Platform中的Type or select the new platform下选择x64，OK。</p></li>
</ol>


<p>对于没有汇编的程序，上述设置就可以了。但如果代码中有汇编代码，则还需要Project下的Custom Build Rules中切换到MASM64 Bulid Rule。</p>

<p>缺省情况下，VS2005没有提供到MASM64 Bulid Rule，需要将原来的masm.rules（在C:\Program Files\Microsoft Visual Studio 8\VC\VCProjectDefaults文件夹下）文件拷贝一份，重新命名为masm64.rules，并在VS2005中修改rule中的ml.exe为ml64.exe即可。</p>

<p>上面设置好之后，就可以在Win32和X64平台间自由切换，但要注意的是，切换的时候也需要将Custom Build Rules切换到相应的平台下。</p>

<h2>VS2005下64位编程的注意事项</h2>

<ul>
<li><p>X64平台下，不支持内联汇编，必须将汇编代码提取到独立的.asm文件中去；</p></li>
<li><p>指针不再是32位，而是64位，汇编代码中涉及32位寄存器间接寻址的，移植时需要修改；</p></li>
<li><p>32位的寄存器被扩展为64位，又增加了一些新的寄存器；</p></li>
<li><p>函数参数的传递与32位下汇编不再相同，而是前4个参数分别通过RCX, RDX, R8, R9来传递，其他的参数通过堆栈来传递；</p></li>
</ul>


<p>上述的应该是最基本的，要在64位平台中进行编程，还需要了解更多的这方面的知识。</p>
]]></content>
  </entry>
  
</feed>
